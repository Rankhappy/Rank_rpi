/**Name: frame.c*Author: Rank *Contact:<441552318@qq.com>*/#include "list.h"#include "type.h"#include "mm.h"#include "mm_internal.h"#define MAX_ORDER 11typedef struct{	uint32_t frames;	list_node_t node;}zone_t;typedef struct{	addr_t base;	uint32_t frames;	list_t free_list[MAX_ORDER+1];}zones_t;static zones_t g_zones;static inline int frames2order(uint32_t frames){	int order = 0;		if(frames >= (1<<MAX_ORDER))	{		return MAX_ORDER;	}		while(frames > 1)	{		order++;		frames >>= 1;	}		return order;}int linear_zones_init(addr_t start, size_t size){	int order;	uint32_t frames;	addr_t paddr;		start = allign_up(start, FRAME_SHIFT);	size = allign_down(size, FRAME_SHIFT);	g_zones.base = start;	g_zones.frames = size>>FRAME_SHIFT;	for(order = 0; order <= MAX_ORDER; order++)	{			list_init(&g_zones.free_list[order]);	}	paddr = g_zones.base;	frames = g_zones.frames;	while(frames)	{		order = frames2order(frames);		zone_t *zone = (zone_t *)phy2vir(paddr, g_v2p_off);		zone->frames = (1 << order);		list_init(&zone->node);		list_add_tail(&g_zones.free_list[order], &zone->node);		paddr += (zone->frames)<<FRAME_SHIFT;		frames -= zone->frames;	}	return 0;}frame_t *alloc_linear_zone(uint32_t frames){	int order, order_i;	zone_t *zone = NULL;	frame_t *frame;	order = frames2order(frames);		for(order_i = order; order_i <= MAX_ORDER; order_i++)	{		if(list_empty(&g_zones.free_list[order_i]))		{			continue;		}			list_node_t *zone_node;		zone_node = list_head(&g_zones.free_list[order_i]);		zone = list_data(zone_node, zone_t, node);		list_delete(&zone->node);		break;	}		if(zone == NULL)	{		return NULL;	}		frame = (frame_t *)low_malloc(sizeof(frame_t));	if(frame == NULL)	{		return NULL;	}	frame->frames = (1<<order);	frame->pfn = vir2phy((addr_t)zone, g_v2p_off)>>FRAME_SHIFT;	while(order_i > order)	{		zone = (zone_t *)((uint32_t)zone+((1<<order)<<FRAME_SHIFT));		{			zone->frames = (1<<order);			list_init(&zone->node);			list_add_tail(&g_zones.free_list[order], &zone->node);		}		order++;	}	return frame;}static zone_t *find_buddy_zone(uint32_t pfn, int order){	zone_t *zone = NULL;	int idx;	idx = pfn - (g_zones.base>>FRAME_SHIFT);	if(idx&((1<<order)-1))	{			return NULL;	}	idx ^= (1<<order);	zone = (zone_t *)(g_zones.base + (idx<<FRAME_SHIFT));	return zone;	}void free_linear_zone(frame_t *frame){	int order;	zone_t *zone, *zone_buddy;	order = frames2order(frame->frames);	zone = (zone_t *)phy2vir(frame->pfn<<FRAME_SHIFT, g_v2p_off);	list_init(&zone->node);	while(order < MAX_ORDER)	{		zone_buddy = find_buddy_zone(frame->pfn, order);		if(zone_buddy == NULL)		{			break;		}		order++;		list_delete(&zone_buddy->node);	}	zone->frames = (1<<order);	list_init(&zone->node);	list_add_tail(&g_zones.free_list[order], &zone->node);	low_free(frame);}