#include "list.h"#include "type.h"#define assert(x)#define MAX_PHY_SIZE (32*1024*1024)#define PAGE_SHIFT (12)#define PAGE_SIZE (1<<PAGE_SHIFT)#define PAGE_MASK (PAGE_SIZE - 1)#define PAGE_ALIGN (~PAGE_MASK)#define MAX_ORDER 10#define ALIGN_DOWN(x, y) (x&(~(y-1)))#define ALIGN_UP(x, y) ((x+(y-1))&(~(y-1)))#define PAGE_ALIGNED(x, name) ALIGN_##name(x, PAGE_SIZE)#define PA2VA(x) ((x)+0x40000000)#define BUDDY_ATTR(x, y) (((x) >> y) >> 1) #define DECLARE_MAP(name, size, index) uint8_t name##index[size] = {0};#define READ_MAP_BIT(array, page, order)  \((array[BUDDY_ATTR((page), order) / 8] >> (BUDDY_ATTR((page), order) % 8))&0x01)#define SET_MAP_BIT(array, page, order) \(array[BUDDY_ATTR((page), order) / 8] ^= (1 << (BUDDY_ATTR((page), order) % 8)))typedef struct{	list_node_t node;	page_t start_page;	//size_t pages;}free_area_t;typedef struct{	page_t base_page;	list_t free_list[MAX_ORDER+1];}phymem_area_t;typedef struct{	void *private;}page_info_t;static phymem_area_t phymem_area;static page_info_t page_info[32*1024];DECLARE_MAP(bmap, MAX_PHY_SIZE >> 4, 0)DECLARE_MAP(bmap, MAX_PHY_SIZE >> 5, 1)DECLARE_MAP(bmap, MAX_PHY_SIZE >> 6, 2)DECLARE_MAP(bmap, MAX_PHY_SIZE >> 7, 3)DECLARE_MAP(bmap, MAX_PHY_SIZE >> 8, 4)DECLARE_MAP(bmap, MAX_PHY_SIZE >> 9, 5)DECLARE_MAP(bmap, MAX_PHY_SIZE >> 10, 6)DECLARE_MAP(bmap, MAX_PHY_SIZE >> 11, 7)DECLARE_MAP(bmap, MAX_PHY_SIZE >> 12, 8)DECLARE_MAP(bmap, MAX_PHY_SIZE >> 13, 9)DECLARE_MAP(bmap, MAX_PHY_SIZE >> 14, 10)static uint8_t *pbmap[MAX_ORDER+1] = {bmap0, bmap1, bmap2, bmap3, \							bmap4, bmap5, bmap6, bmap7, \							bmap8, bmap9, bmap10};							extern void printf(const char *fmt, ...);void set_page_info(page_t pages, void *data){	page_info[pages - phymem_area.base_page].private = data;}void *get_page_info(page_t pages){	return page_info[pages - phymem_area.base_page].private;}static int Pages2Order(size_t pages){		int order;		if((pages == 0) || (pages > (1 << MAX_ORDER)))	{		return -1;	}		for(order = MAX_ORDER; order >= 0; order--)	{		if(pages & (1 << order))		{			if(pages & ((1 << order) - 1))			{				order++;			}			return order;		}	}		return -1;}//page_t alloc_pages(size_t pages);int init_phymem_area(addr_t start, size_t size){	int order;	page_t start_page;	size_t pages;	//printf("start = 0x%08x\n", start);		start = PAGE_ALIGNED(start, UP);	size = PAGE_ALIGNED(size, DOWN);		start_page = start >> PAGE_SHIFT;	pages = size >> PAGE_SHIFT;	//printf("phymem_area = %x\n", (uint32_t)&phymem_area);	phymem_area.base_page = start_page;	for(order = 0; order <= MAX_ORDER; order++)	{			list_init(&phymem_area.free_list[order]);	}	for(order = MAX_ORDER; order >= 0; order--)	{		while(pages >> order)		{			free_area_t *fa = (free_area_t *)(unsigned long)(PA2VA(start_page << PAGE_SHIFT));			list_init(&fa->node);			fa->start_page = start_page;			printf("fa->node = 0x%08x\n", (uint32_t)(&fa->node));			printf("fa->start_page = 0x%08x, order = %d\n", fa->start_page, order);			list_add_tail(&phymem_area.free_list[order], &fa->node);			SET_MAP_BIT(pbmap[order], start_page-phymem_area.base_page, order);						start_page += 1 << order;			pages -= 1 << order;		}	}		return 0;}void print_list(void){	list_node_t *n;	list_foreach(&phymem_area.free_list[MAX_ORDER], n)	{		printf("n = 0x%08x\n", (uint32_t)n);	}}page_t alloc_pages(size_t pages){	int i;	free_area_t *fa;	int order = Pages2Order(pages);		printf("order = %d\n", order);	//printf("fa = 0x%08x\n", (uint32_t)fa);		if(order == -1)	{		return -1;	}		for(i = order; i <= MAX_ORDER; i++)	{		if(list_empty(&phymem_area.free_list[i]))		{			continue;		}		else		{			list_node_t *n;			list_foreach(&phymem_area.free_list[i], n)			{				//printf("n = 0x%08x\n", (uint32_t)n);			}			fa = list_data(list_head(&phymem_area.free_list[i]), free_area_t, node);			//printf("i = %d, node = 0x%08x\n", i, (uint32_t)list_head(&phymem_area.free_list[i]));			list_delete(&fa->node);			SET_MAP_BIT(pbmap[i], fa->start_page-phymem_area.base_page, i);					break;		}	}		//printf("i = %d, order = %d.\n", i, order);	//printf("fa = 0x%08x\n", (uint32_t)fa);	//printf("fa->start_page = 0x%08x\n", fa->start_page);		if((i != order) && (i <= MAX_ORDER))	{		printf("i = %d, order = %d.\n", i, order);		page_t start_page = fa->start_page + (1 << order);		while(order < i)		{			//printf("order = %d.\n", order);			free_area_t *fax = (free_area_t *)(unsigned long)(PA2VA(start_page << PAGE_SHIFT));			//printf("fax = 0x%08x.\n", fax);			list_init(&fax->node);			fax->start_page = start_page;			list_add_tail(&phymem_area.free_list[order], &fax->node);			SET_MAP_BIT(pbmap[order], fax->start_page-phymem_area.base_page, order);				start_page += (1 << order);			order++;		}	}		if(fa)	{		return fa->start_page;	}		return -1;}void free_pages(page_t start_page, size_t pages){	int order = Pages2Order(pages);	list_node_t *node;		if(order == -1)	{		return;	}		while(order <= MAX_ORDER)	{		if(READ_MAP_BIT(pbmap[order], start_page - phymem_area.base_page, order) == 0)		{			free_area_t *fa = (free_area_t *)(unsigned long)(PA2VA(start_page << PAGE_SHIFT));			list_init(&fa->node);			fa->start_page = start_page;			list_add_tail(&phymem_area.free_list[order], &fa->node);			SET_MAP_BIT(pbmap[order], fa->start_page-phymem_area.base_page, order);				return;		}				list_foreach(&phymem_area.free_list[order], node)		{				free_area_t *fa = list_data(node, free_area_t, node);			//printf("order = %d\n", order);			//printf("%lx, %lx\n", fa->start_page - phymem_area.base_page, start_page - phymem_area.base_page);			if(BUDDY_ATTR(fa->start_page - phymem_area.base_page, order) == \				BUDDY_ATTR(start_page - phymem_area.base_page, order))			{				//printf("find buddy.\n");				list_delete(&fa->node);					SET_MAP_BIT(pbmap[order], fa->start_page-phymem_area.base_page, order);					start_page = fa->start_page < start_page?fa->start_page:start_page;				break;			}		}				assert(node != &phymem_area.free_list[order]);#if 0		if(node == &phymem_area.free_list[order])		{			//printf("order = %d\n", order);			free_area_t *fa = (free_area_t *)(unsigned long)(PA2VA(start_page << PAGE_SHIFT));			list_init(&fa->node);			fa->start_page = start_page;			list_add_tail(&phymem_area.free_list[order], &fa->node);			break;		}#endif		order++;	}}#if 0int page_test(addr_t addr, size_t size){	page_t pages;	printf("addr = 0x%08x\n", addr);		init_phymem_area(addr, size);		printf("pages = 0x%08x\n", pages = alloc_pages(512));	printf("pages = 0x%08x\n", pages = alloc_pages(512));	free_pages(pages, 512);		printf("pages = 0x%08x\n", pages = alloc_pages(256));		free_pages(pages, 256);		printf("pages = 0x%08x\n", pages = alloc_pages(512));		return 0;}#endif